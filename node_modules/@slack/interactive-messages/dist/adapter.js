'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _http = require('http');

var _http2 = _interopRequireDefault(_http);

var _axios = require('axios');

var _axios2 = _interopRequireDefault(_axios);

var _lodash = require('lodash.isstring');

var _lodash2 = _interopRequireDefault(_lodash);

var _lodash3 = require('lodash.isplainobject');

var _lodash4 = _interopRequireDefault(_lodash3);

var _lodash5 = require('lodash.isregexp');

var _lodash6 = _interopRequireDefault(_lodash5);

var _lodash7 = require('lodash.isfunction');

var _lodash8 = _interopRequireDefault(_lodash7);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _expressMiddleware = require('./express-middleware');

var _util = require('./util');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var debug = (0, _debug2.default)('@slack/interactive-messages:adapter');

/**
 * Transforms various forms of matching constraints to a single standard object shape
 * @param {string|RegExp|Object} matchingConstraints - the various forms of matching constraints
 * accepted
 * @returns {Object} - an object where each matching constraint is a property
 */
function formatMatchingConstraints(matchingConstraints) {
  var ret = {};
  if (!(0, _lodash4.default)(matchingConstraints)) {
    ret.callbackId = matchingConstraints;
  } else {
    ret = Object.assign({}, matchingConstraints);
  }
  return ret;
}

/**
 * Validates general properties of a matching constraints object
 * @param {Object} matchingConstraints - object describing the constraints on a callback
 * @return {Error|false} - a false value represents successful validation, otherwise an error to
 * describe why validation failed.
 */
function validateConstraints(matchingConstraints) {
  if (matchingConstraints.callbackId && !((0, _lodash2.default)(matchingConstraints.callbackId) || (0, _lodash6.default)(matchingConstraints.callbackId))) {
    return new TypeError('Callback ID must be a string or RegExp');
  }

  return false;
}

/**
 * Validates properties of a matching constraints object specific to registering an action
 * @param {Object} matchingConstraints - object describing the constraints on a callback
 * @return {Error|false} - a false value represents successful validation, otherwise an error to
 * describe why validation failed.
 */
function validateActionConstraints(actionConstraints) {
  if (actionConstraints.type && !(actionConstraints.type === 'select' || actionConstraints.type === 'button')) {
    return new TypeError('Type must be \'select\' or \'button\'');
  }

  // We don't need to validate unfurl, we'll just cooerce it to a boolean
  return false;
}

var SlackMessageAdapter = function () {
  /**
   * Create a message adapter.
   *
   * @param {string} verificationToken - Slack app verification token used to authenticate request
   */
  function SlackMessageAdapter(verificationToken) {
    _classCallCheck(this, SlackMessageAdapter);

    if (!(0, _lodash2.default)(verificationToken)) {
      throw new TypeError('SlackMessageAdapter needs a verification token');
    }

    this.verificationToken = verificationToken;
    this.callbacks = [];
    this.axios = _axios2.default.create({
      headers: {
        'User-Agent': (0, _util.packageIdentifier)()
      }
    });

    debug('instantiated');
  }

  /**
   * Create a server that's ready to serve requests from Slack's interactive messages.
   *
   * @param {string} [path=/slack/actions] - The path portion of the URL where the server will
   * listen for requests from Slack's interactive messages.
   */


  _createClass(SlackMessageAdapter, [{
    key: 'createServer',
    value: function createServer() {
      var _this = this;

      var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '/slack/actions';

      // TODO: more options (like https)
      return Promise.resolve().then(function () {
        return Promise.all([Promise.resolve(require(('express'))), Promise.resolve(require(('body-parser')))]);
      }).then(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            express = _ref2[0],
            bodyParser = _ref2[1];

        var app = express();
        app.use(bodyParser.urlencoded({ extended: false }));
        app.post(path, _this.expressMiddleware());

        debug('server created - path: %s', path);

        return _http2.default.createServer(app);
      });
    }
  }, {
    key: 'start',
    value: function start(port) {
      var _this2 = this;

      return this.createServer().then(function (server) {
        return new Promise(function (resolve, reject) {
          _this2.server = server;
          server.on('error', reject);
          server.listen(port, function () {
            return resolve(server);
          });
          debug('server started - port: %s', port);
        });
      });
    }
  }, {
    key: 'stop',
    value: function stop() {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        if (_this3.server) {
          _this3.server.close(function (error) {
            delete _this3.server;
            if (error) {
              reject(error);
            } else {
              resolve();
            }
          });
        } else {
          reject(new Error('SlackMessageAdapter cannot stop when it did not start a server'));
        }
      });
    }
  }, {
    key: 'expressMiddleware',
    value: function expressMiddleware() {
      return (0, _expressMiddleware.createExpressMiddleware)(this);
    }
  }, {
    key: 'action',
    value: function action(matchingConstraints, callback) {
      var actionConstraints = formatMatchingConstraints(matchingConstraints);

      var error = validateConstraints(actionConstraints) || validateActionConstraints(actionConstraints);
      if (error) {
        debug('action could not be registered: %s', error.message);
        throw error;
      }

      return this.registerCallback(actionConstraints, callback);
    }
  }, {
    key: 'options',
    value: function options(matchingConstraints, callback) {
      var optionsConstraints = formatMatchingConstraints(matchingConstraints);

      var error = validateConstraints(optionsConstraints);
      if (error) {
        debug('options could not be registered: %s', error.message);
        throw error;
      }

      return this.registerCallback(optionsConstraints, callback);
    }

    /* @private */

  }, {
    key: 'registerCallback',
    value: function registerCallback(constraints, callback) {
      // Validation
      if (!(0, _lodash8.default)(callback)) {
        debug('did not register callback because its not a function');
        throw new TypeError('callback must be a function');
      }

      this.callbacks.push([constraints, callback]);

      return this;
    }
  }, {
    key: 'dispatch',
    value: function dispatch(payload) {
      var _this4 = this;

      var action = payload.actions && payload.actions[0];
      // The following result value represents "no replacement"
      var result = { status: 200 };
      var respond = function respond(message) {
        debug('sending async response');
        return _this4.axios.post(payload.response_url, message);
      };

      this.callbacks.some(function (_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2),
            constraints = _ref4[0],
            fn = _ref4[1];

        // Returning false in this function continues the iteration, and returning true ends it.
        // The pattern is that we assign a value to `result` and then return true. We only desire one
        // result for the response.
        var callbackResult = void 0;

        if (constraints.callbackId) {
          if ((0, _lodash2.default)(constraints.callbackId) && payload.callback_id !== constraints.callbackId) {
            return false;
          }
          if ((0, _lodash6.default)(constraints.callbackId) && !constraints.callbackId.test(payload.callback_id)) {
            return false;
          }
        }

        if (action && constraints.type && constraints.type !== action.type) {
          return false;
        }

        if ('unfurl' in constraints && (constraints.unfurl && !payload.is_app_unfurl || !constraints.unfurl && payload.is_app_unfurl)) {
          return false;
        }

        try {
          callbackResult = fn.call(_this4, payload, respond);
        } catch (error) {
          debug('callback error: %o', error);
          result = { status: 500 };
          return true;
        }

        if (callbackResult) {
          // Checking for Promise type
          if (typeof callbackResult.then === 'function') {
            callbackResult.then(respond).catch(function (error) {
              debug('async error for callback. callback_id: %s, error: %s', payload.callback_id, error.message);
            });
            return true;
          }
          result = { status: 200, content: callbackResult };
          return true;
        }
        return true;
      });

      return result;
    }
  }]);

  return SlackMessageAdapter;
}();

exports.default = SlackMessageAdapter;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9hZGFwdGVyLmpzIl0sIm5hbWVzIjpbImRlYnVnIiwiZm9ybWF0TWF0Y2hpbmdDb25zdHJhaW50cyIsIm1hdGNoaW5nQ29uc3RyYWludHMiLCJyZXQiLCJjYWxsYmFja0lkIiwiT2JqZWN0IiwiYXNzaWduIiwidmFsaWRhdGVDb25zdHJhaW50cyIsIlR5cGVFcnJvciIsInZhbGlkYXRlQWN0aW9uQ29uc3RyYWludHMiLCJhY3Rpb25Db25zdHJhaW50cyIsInR5cGUiLCJTbGFja01lc3NhZ2VBZGFwdGVyIiwidmVyaWZpY2F0aW9uVG9rZW4iLCJjYWxsYmFja3MiLCJheGlvcyIsImNyZWF0ZSIsImhlYWRlcnMiLCJwYXRoIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwiYWxsIiwiZXhwcmVzcyIsImJvZHlQYXJzZXIiLCJhcHAiLCJ1c2UiLCJ1cmxlbmNvZGVkIiwiZXh0ZW5kZWQiLCJwb3N0IiwiZXhwcmVzc01pZGRsZXdhcmUiLCJjcmVhdGVTZXJ2ZXIiLCJwb3J0IiwicmVqZWN0Iiwic2VydmVyIiwib24iLCJsaXN0ZW4iLCJjbG9zZSIsImVycm9yIiwiRXJyb3IiLCJjYWxsYmFjayIsIm1lc3NhZ2UiLCJyZWdpc3RlckNhbGxiYWNrIiwib3B0aW9uc0NvbnN0cmFpbnRzIiwiY29uc3RyYWludHMiLCJwdXNoIiwicGF5bG9hZCIsImFjdGlvbiIsImFjdGlvbnMiLCJyZXN1bHQiLCJzdGF0dXMiLCJyZXNwb25kIiwicmVzcG9uc2VfdXJsIiwic29tZSIsImZuIiwiY2FsbGJhY2tSZXN1bHQiLCJjYWxsYmFja19pZCIsInRlc3QiLCJ1bmZ1cmwiLCJpc19hcHBfdW5mdXJsIiwiY2FsbCIsImNhdGNoIiwiY29udGVudCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7OztBQUVBLElBQU1BLFFBQVEscUJBQWEscUNBQWIs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QU9wQyxJQUE5RCxFQUFvRTtBQUNsRSxpQkFBTyxLQUFQO0FBQ0Q7O0FBRUQsWUFBSSxZQUFZaUMsV0FBWixLQUVJQSxZQUFZYyxNQUFaLElBQXNCLENBQUNaLFFBQVFhLGFBQWhDLElBQ0MsQ0FBQ2YsWUFBWWMsTUFBYixJQUF1QlosUUFBUWEsYUFIbkMsQ0FBSixFQUtLO0FBQ0gsaUJBQU8sS0FBUDtBQUNEOztBQUVELFlBQUk7QUFDRkosMkJBQWlCRCxHQUFHTSxJQUFILFNBQWNkLE9BQWQsRUFBdUJLLE9BQXZCLENBQWpCO0FBQ0QsU0FGRCxDQUVFLE9BQU9iLEtBQVAsRUFBYztBQUNkdEMsZ0JBQU0sb0JBQU4sRUFBNEJzQyxLQUE1QjtBQUNBVyxtQkFBUyxFQUFFQyxRQUFRLEdBQVYsRUFBVDtBQUNBLGlCQUFPLElBQVA7QUFDRDs7QUFFRCxZQUFJSyxjQUFKLEVBQW9CO0FBQ2xCO0FBQ0EsY0FBSSxPQUFPQSxlQUFlbEMsSUFBdEIsS0FBK0IsVUFBbkMsRUFBK0M7QUFDN0NrQywyQkFBZWxDLElBQWYsQ0FBb0I4QixPQUFwQixFQUE2QlUsS0FBN0IsQ0FBbUMsVUFBQ3ZCLEtBQUQsRUFBVztBQUM1Q3RDLG9CQUFNLHNEQUFOLEVBQ004QyxRQUFRVSxXQURkLEVBQzJCbEIsTUFBTUcsT0FEakM7QUFFRCxhQUhEO0FBSUEsbUJBQU8sSUFBUDtBQUNEO0FBQ0RRLG1CQUFTLEVBQUVDLFFBQVEsR0FBVixFQUFlWSxTQUFTUCxjQUF4QixFQUFUO0FBQ0EsaUJBQU8sSUFBUDtBQUNEO0FBQ0QsZUFBTyxJQUFQO0FBQ0QsT0FqREQ7O0FBbURBLGFBQU9OLE1BQVA7QUFDRDs7Ozs7O2tCQWhMa0JyQyxtQiIsImZpbGUiOiJhZGFwdGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGh0dHAgZnJvbSAnaHR0cCc7XG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xuaW1wb3J0IGlzU3RyaW5nIGZyb20gJ2xvZGFzaC5pc3N0cmluZyc7XG5pbXBvcnQgaXNQbGFpbk9iamVjdCBmcm9tICdsb2Rhc2guaXNwbGFpbm9iamVjdCc7XG5pbXBvcnQgaXNSZWdFeHAgZnJvbSAnbG9kYXNoLmlzcmVnZXhwJztcbmltcG9ydCBpc0Z1bmN0aW9uIGZyb20gJ2xvZGFzaC5pc2Z1bmN0aW9uJztcbmltcG9ydCBkZWJ1Z0ZhY3RvcnkgZnJvbSAnZGVidWcnO1xuaW1wb3J0IHsgY3JlYXRlRXhwcmVzc01pZGRsZXdhcmUgfSBmcm9tICcuL2V4cHJlc3MtbWlkZGxld2FyZSc7XG5pbXBvcnQgeyBwYWNrYWdlSWRlbnRpZmllciB9IGZyb20gJy4vdXRpbCc7XG5cbmNvbnN0IGRlYnVnID0gZGVidWdGYWN0b3J5KCdAc2xhY2svaW50ZXJhY3RpdmUtbWVzc2FnZXM6YWRhcHRlcicpO1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdmFyaW91cyBmb3JtcyBvZiBtYXRjaGluZyBjb25zdHJhaW50cyB0byBhIHNpbmdsZSBzdGFuZGFyZCBvYmplY3Qgc2hhcGVcbiAqIEBwYXJhbSB7c3RyaW5nfFJlZ0V4cHxPYmplY3R9IG1hdGNoaW5nQ29uc3RyYWludHMgLSB0aGUgdmFyaW91cyBmb3JtcyBvZiBtYXRjaGluZyBjb25zdHJhaW50c1xuICogYWNjZXB0ZWRcbiAqIEByZXR1cm5zIHtPYmplY3R9IC0gYW4gb2JqZWN0IHdoZXJlIGVhY2ggbWF0Y2hpbmcgY29uc3RyYWludCBpcyBhIHByb3BlcnR5XG4gKi9cbmZ1bmN0aW9uIGZvcm1hdE1hdGNoaW5nQ29uc3RyYWludHMobWF0Y2hpbmdDb25zdHJhaW50cykge1xuICBsZXQgcmV0ID0ge307XG4gIGlmICghaXNQbGFpbk9iamVjdChtYXRjaGluZ0NvbnN0cmFpbnRzKSkge1xuICAgIHJldC5jYWxsYmFja0lkID0gbWF0Y2hpbmdDb25zdHJhaW50cztcbiAgfSBlbHNlIHtcbiAgICByZXQgPSBPYmplY3QuYXNzaWduKHt9LCBtYXRjaGluZ0NvbnN0cmFpbnRzKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIFZhbGlkYXRlcyBnZW5lcmFsIHByb3BlcnRpZXMgb2YgYSBtYXRjaGluZyBjb25zdHJhaW50cyBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXRjaGluZ0NvbnN0cmFpbnRzIC0gb2JqZWN0IGRlc2NyaWJpbmcgdGhlIGNvbnN0cmFpbnRzIG9uIGEgY2FsbGJhY2tcbiAqIEByZXR1cm4ge0Vycm9yfGZhbHNlfSAtIGEgZmFsc2UgdmFsdWUgcmVwcmVzZW50cyBzdWNjZXNzZnVsIHZhbGlkYXRpb24sIG90aGVyd2lzZSBhbiBlcnJvciB0b1xuICogZGVzY3JpYmUgd2h5IHZhbGlkYXRpb24gZmFpbGVkLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNvbnN0cmFpbnRzKG1hdGNoaW5nQ29uc3RyYWludHMpIHtcbiAgaWYgKG1hdGNoaW5nQ29uc3RyYWludHMuY2FsbGJhY2tJZCAmJlxuICAgICAgIShpc1N0cmluZyhtYXRjaGluZ0NvbnN0cmFpbnRzLmNhbGxiYWNrSWQpIHx8IGlzUmVnRXhwKG1hdGNoaW5nQ29uc3RyYWludHMuY2FsbGJhY2tJZCkpKSB7XG4gICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoJ0NhbGxiYWNrIElEIG11c3QgYmUgYSBzdHJpbmcgb3IgUmVnRXhwJyk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogVmFsaWRhdGVzIHByb3BlcnRpZXMgb2YgYSBtYXRjaGluZyBjb25zdHJhaW50cyBvYmplY3Qgc3BlY2lmaWMgdG8gcmVnaXN0ZXJpbmcgYW4gYWN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gbWF0Y2hpbmdDb25zdHJhaW50cyAtIG9iamVjdCBkZXNjcmliaW5nIHRoZSBjb25zdHJhaW50cyBvbiBhIGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtFcnJvcnxmYWxzZX0gLSBhIGZhbHNlIHZhbHVlIHJlcHJlc2VudHMgc3VjY2Vzc2Z1bCB2YWxpZGF0aW9uLCBvdGhlcndpc2UgYW4gZXJyb3IgdG9cbiAqIGRlc2NyaWJlIHdoeSB2YWxpZGF0aW9uIGZhaWxlZC5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVBY3Rpb25Db25zdHJhaW50cyhhY3Rpb25Db25zdHJhaW50cykge1xuICBpZiAoYWN0aW9uQ29uc3RyYWludHMudHlwZSAmJlxuICAgICAgIShhY3Rpb25Db25zdHJhaW50cy50eXBlID09PSAnc2VsZWN0JyB8fCBhY3Rpb25Db25zdHJhaW50cy50eXBlID09PSAnYnV0dG9uJykpIHtcbiAgICByZXR1cm4gbmV3IFR5cGVFcnJvcignVHlwZSBtdXN0IGJlIFxcJ3NlbGVjdFxcJyBvciBcXCdidXR0b25cXCcnKTtcbiAgfVxuXG4gIC8vIFdlIGRvbid0IG5lZWQgdG8gdmFsaWRhdGUgdW5mdXJsLCB3ZSdsbCBqdXN0IGNvb2VyY2UgaXQgdG8gYSBib29sZWFuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2xhY2tNZXNzYWdlQWRhcHRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBtZXNzYWdlIGFkYXB0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2ZXJpZmljYXRpb25Ub2tlbiAtIFNsYWNrIGFwcCB2ZXJpZmljYXRpb24gdG9rZW4gdXNlZCB0byBhdXRoZW50aWNhdGUgcmVxdWVzdFxuICAgKi9cbiAgY29uc3RydWN0b3IodmVyaWZpY2F0aW9uVG9rZW4pIHtcbiAgICBpZiAoIWlzU3RyaW5nKHZlcmlmaWNhdGlvblRva2VuKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU2xhY2tNZXNzYWdlQWRhcHRlciBuZWVkcyBhIHZlcmlmaWNhdGlvbiB0b2tlbicpO1xuICAgIH1cblxuICAgIHRoaXMudmVyaWZpY2F0aW9uVG9rZW4gPSB2ZXJpZmljYXRpb25Ub2tlbjtcbiAgICB0aGlzLmNhbGxiYWNrcyA9IFtdO1xuICAgIHRoaXMuYXhpb3MgPSBheGlvcy5jcmVhdGUoe1xuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnVXNlci1BZ2VudCc6IHBhY2thZ2VJZGVudGlmaWVyKCksXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgZGVidWcoJ2luc3RhbnRpYXRlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHNlcnZlciB0aGF0J3MgcmVhZHkgdG8gc2VydmUgcmVxdWVzdHMgZnJvbSBTbGFjaydzIGludGVyYWN0aXZlIG1lc3NhZ2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhdGg9L3NsYWNrL2FjdGlvbnNdIC0gVGhlIHBhdGggcG9ydGlvbiBvZiB0aGUgVVJMIHdoZXJlIHRoZSBzZXJ2ZXIgd2lsbFxuICAgKiBsaXN0ZW4gZm9yIHJlcXVlc3RzIGZyb20gU2xhY2sncyBpbnRlcmFjdGl2ZSBtZXNzYWdlcy5cbiAgICovXG4gIGNyZWF0ZVNlcnZlcihwYXRoID0gJy9zbGFjay9hY3Rpb25zJykge1xuICAgIC8vIFRPRE86IG1vcmUgb3B0aW9ucyAobGlrZSBodHRwcylcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiBQcm9taXNlLmFsbChbXG4gICAgICBpbXBvcnQoJ2V4cHJlc3MnKSxcbiAgICAgIGltcG9ydCgnYm9keS1wYXJzZXInKSxcbiAgICBdKSlcbiAgICAudGhlbigoW2V4cHJlc3MsIGJvZHlQYXJzZXJdKSA9PiB7XG4gICAgICBjb25zdCBhcHAgPSBleHByZXNzKCk7XG4gICAgICBhcHAudXNlKGJvZHlQYXJzZXIudXJsZW5jb2RlZCh7IGV4dGVuZGVkOiBmYWxzZSB9KSk7XG4gICAgICBhcHAucG9zdChwYXRoLCB0aGlzLmV4cHJlc3NNaWRkbGV3YXJlKCkpO1xuXG4gICAgICBkZWJ1Zygnc2VydmVyIGNyZWF0ZWQgLSBwYXRoOiAlcycsIHBhdGgpO1xuXG4gICAgICByZXR1cm4gaHR0cC5jcmVhdGVTZXJ2ZXIoYXBwKTtcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXJ0KHBvcnQpIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVTZXJ2ZXIoKVxuICAgICAgLnRoZW4oc2VydmVyID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdGhpcy5zZXJ2ZXIgPSBzZXJ2ZXI7XG4gICAgICAgIHNlcnZlci5vbignZXJyb3InLCByZWplY3QpO1xuICAgICAgICBzZXJ2ZXIubGlzdGVuKHBvcnQsICgpID0+IHJlc29sdmUoc2VydmVyKSk7XG4gICAgICAgIGRlYnVnKCdzZXJ2ZXIgc3RhcnRlZCAtIHBvcnQ6ICVzJywgcG9ydCk7XG4gICAgICB9KSk7XG4gIH1cblxuICBzdG9wKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAodGhpcy5zZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5zZXJ2ZXIuY2xvc2UoKGVycm9yKSA9PiB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuc2VydmVyO1xuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKCdTbGFja01lc3NhZ2VBZGFwdGVyIGNhbm5vdCBzdG9wIHdoZW4gaXQgZGlkIG5vdCBzdGFydCBhIHNlcnZlcicpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGV4cHJlc3NNaWRkbGV3YXJlKCkge1xuICAgIHJldHVybiBjcmVhdGVFeHByZXNzTWlkZGxld2FyZSh0aGlzKTtcbiAgfVxuXG4gIGFjdGlvbihtYXRjaGluZ0NvbnN0cmFpbnRzLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGFjdGlvbkNvbnN0cmFpbnRzID0gZm9ybWF0TWF0Y2hpbmdDb25zdHJhaW50cyhtYXRjaGluZ0NvbnN0cmFpbnRzKTtcblxuICAgIGNvbnN0IGVycm9yID0gdmFsaWRhdGVDb25zdHJhaW50cyhhY3Rpb25Db25zdHJhaW50cykgfHxcbiAgICAgIHZhbGlkYXRlQWN0aW9uQ29uc3RyYWludHMoYWN0aW9uQ29uc3RyYWludHMpO1xuICAgIGlmIChlcnJvcikge1xuICAgICAgZGVidWcoJ2FjdGlvbiBjb3VsZCBub3QgYmUgcmVnaXN0ZXJlZDogJXMnLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnJlZ2lzdGVyQ2FsbGJhY2soYWN0aW9uQ29uc3RyYWludHMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIG9wdGlvbnMobWF0Y2hpbmdDb25zdHJhaW50cywgY2FsbGJhY2spIHtcbiAgICBjb25zdCBvcHRpb25zQ29uc3RyYWludHMgPSBmb3JtYXRNYXRjaGluZ0NvbnN0cmFpbnRzKG1hdGNoaW5nQ29uc3RyYWludHMpO1xuXG4gICAgY29uc3QgZXJyb3IgPSB2YWxpZGF0ZUNvbnN0cmFpbnRzKG9wdGlvbnNDb25zdHJhaW50cyk7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBkZWJ1Zygnb3B0aW9ucyBjb3VsZCBub3QgYmUgcmVnaXN0ZXJlZDogJXMnLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnJlZ2lzdGVyQ2FsbGJhY2sob3B0aW9uc0NvbnN0cmFpbnRzLCBjYWxsYmFjayk7XG4gIH1cblxuICAvKiBAcHJpdmF0ZSAqL1xuXG4gIHJlZ2lzdGVyQ2FsbGJhY2soY29uc3RyYWludHMsIGNhbGxiYWNrKSB7XG4gICAgLy8gVmFsaWRhdGlvblxuICAgIGlmICghaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgIGRlYnVnKCdkaWQgbm90IHJlZ2lzdGVyIGNhbGxiYWNrIGJlY2F1c2UgaXRzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICB0aGlzLmNhbGxiYWNrcy5wdXNoKFtjb25zdHJhaW50cywgY2FsbGJhY2tdKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZGlzcGF0Y2gocGF5bG9hZCkge1xuICAgIGNvbnN0IGFjdGlvbiA9IHBheWxvYWQuYWN0aW9ucyAmJiBwYXlsb2FkLmFjdGlvbnNbMF07XG4gICAgLy8gVGhlIGZvbGxvd2luZyByZXN1bHQgdmFsdWUgcmVwcmVzZW50cyBcIm5vIHJlcGxhY2VtZW50XCJcbiAgICBsZXQgcmVzdWx0ID0geyBzdGF0dXM6IDIwMCB9O1xuICAgIGNvbnN0IHJlc3BvbmQgPSAobWVzc2FnZSkgPT4ge1xuICAgICAgZGVidWcoJ3NlbmRpbmcgYXN5bmMgcmVzcG9uc2UnKTtcbiAgICAgIHJldHVybiB0aGlzLmF4aW9zLnBvc3QocGF5bG9hZC5yZXNwb25zZV91cmwsIG1lc3NhZ2UpO1xuICAgIH07XG5cbiAgICB0aGlzLmNhbGxiYWNrcy5zb21lKChbY29uc3RyYWludHMsIGZuXSkgPT4ge1xuICAgICAgLy8gUmV0dXJuaW5nIGZhbHNlIGluIHRoaXMgZnVuY3Rpb24gY29udGludWVzIHRoZSBpdGVyYXRpb24sIGFuZCByZXR1cm5pbmcgdHJ1ZSBlbmRzIGl0LlxuICAgICAgLy8gVGhlIHBhdHRlcm4gaXMgdGhhdCB3ZSBhc3NpZ24gYSB2YWx1ZSB0byBgcmVzdWx0YCBhbmQgdGhlbiByZXR1cm4gdHJ1ZS4gV2Ugb25seSBkZXNpcmUgb25lXG4gICAgICAvLyByZXN1bHQgZm9yIHRoZSByZXNwb25zZS5cbiAgICAgIGxldCBjYWxsYmFja1Jlc3VsdDtcblxuICAgICAgaWYgKGNvbnN0cmFpbnRzLmNhbGxiYWNrSWQpIHtcbiAgICAgICAgaWYgKGlzU3RyaW5nKGNvbnN0cmFpbnRzLmNhbGxiYWNrSWQpICYmIHBheWxvYWQuY2FsbGJhY2tfaWQgIT09IGNvbnN0cmFpbnRzLmNhbGxiYWNrSWQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUmVnRXhwKGNvbnN0cmFpbnRzLmNhbGxiYWNrSWQpICYmICFjb25zdHJhaW50cy5jYWxsYmFja0lkLnRlc3QocGF5bG9hZC5jYWxsYmFja19pZCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGFjdGlvbiAmJiBjb25zdHJhaW50cy50eXBlICYmIGNvbnN0cmFpbnRzLnR5cGUgIT09IGFjdGlvbi50eXBlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCd1bmZ1cmwnIGluIGNvbnN0cmFpbnRzICYmXG4gICAgICAgICAgIChcbiAgICAgICAgICAgICAoY29uc3RyYWludHMudW5mdXJsICYmICFwYXlsb2FkLmlzX2FwcF91bmZ1cmwpIHx8XG4gICAgICAgICAgICAgKCFjb25zdHJhaW50cy51bmZ1cmwgJiYgcGF5bG9hZC5pc19hcHBfdW5mdXJsKVxuICAgICAgICAgICApXG4gICAgICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBjYWxsYmFja1Jlc3VsdCA9IGZuLmNhbGwodGhpcywgcGF5bG9hZCwgcmVzcG9uZCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBkZWJ1ZygnY2FsbGJhY2sgZXJyb3I6ICVvJywgZXJyb3IpO1xuICAgICAgICByZXN1bHQgPSB7IHN0YXR1czogNTAwIH07XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FsbGJhY2tSZXN1bHQpIHtcbiAgICAgICAgLy8gQ2hlY2tpbmcgZm9yIFByb21pc2UgdHlwZVxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrUmVzdWx0LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjYWxsYmFja1Jlc3VsdC50aGVuKHJlc3BvbmQpLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgZGVidWcoJ2FzeW5jIGVycm9yIGZvciBjYWxsYmFjay4gY2FsbGJhY2tfaWQ6ICVzLCBlcnJvcjogJXMnLFxuICAgICAgICAgICAgICAgICAgcGF5bG9hZC5jYWxsYmFja19pZCwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0geyBzdGF0dXM6IDIwMCwgY29udGVudDogY2FsbGJhY2tSZXN1bHQgfTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbiJdfQ==
//# sourceMappingURL=adapter.js.map